package com.iitb.MapperBot;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import com.iitb.fb5.Basic.Firebird;

import android.app.Activity;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;

public class MapperBotActivity extends Activity {
	
	private static final String TAG = "MapperBot";
	
	/** GUI Elements */
	Button cmdFwd;
	Button cmdBck;
	Button cmdLft;
	Button cmdRgt;
	
	Button mConnectButton;
	Button mDisconnectButton;
	Button mMapperButton;
	Button mResetButton;
	Button mStopButton;
	Button mMailButton;
	
	/** Wall Following Elements */
	class BotMove {
		int count;
		int state;
		public BotMove (int count, int state) {
			this.count = count;
			this.state = state;
		}
		public static final int STOP = 0;
		public static final int SHARP_RIGHT = 1;
		public static final int LEFT = 2;
		public static final int SOFT_RIGHT = 3;
		public static final int FORWARD = 4;
		public static final int RIGHT_15 = 6;
		public static final int RIGHT_10 = 7;
		public static final int LEFT_5 = 8;
	}
	
	final int MIN_WALL_THRESHOLD = 150;
	final int MAX_WALL_THRESHOLD = 200;
	final int LEFT_SHARP_MIN_THRESHOLD = 100;
	final int LEFT_SHARP_MAX_THRESHOLD = 120;
	final int FWD_SHARP_MIN_THRESHOLD = 70;
	final int FWD_SHARP_MAX_THRESHOLD = 100;
	final int FORWARD_PROX_THRESHOLD = 210;
	final int LEFT_PROX_MIN_THRESHOLD = 210;
	final int LEFT_PROX_MAX_THRESHOLD = 245;
	
	final int FORWARD_SHARP_VALUE = 11;
	final int FORWARD_PROX_VALUE = 6;
	final int LEFT_SHARP_VALUE = 9;
	final int LEFT_PROX_VALUE = 4;
	final int ACC_CHECK = 79;
	
	final int INTERRUPT_COUNT = 81;
	final int TURN_SUCCESS = 111;
	
	int leftsharp,forwardsharp, leftprox, fwdprox, acccheck;
	int wall_expected = 0;
	double distanceTravelled;
	int botState = 0; // 0 => wall finding, 1 => wall following
	
	
	/** For displaying bot movements */
	class MyPoint{
		public float x;
		public float y;
		
		MyPoint(){
			x = 0;
			y = 0;
		}
		
		MyPoint(float a, float b){
			x = a;
			y = b;
		}
		
		MyPoint(MyPoint p){
			x = p.x;
			y = p.y;
		}		
	}
	
	ArrayList<MyPoint> path;
	ArrayList<MyPoint> screenPath;
	MyPoint curr;
	int orientation;
	int angle;
	
	Canvas mCanvas;
	Bitmap mBitmap;
	private Paint cpaint = new Paint(Paint.ANTI_ALIAS_FLAG);
	private Paint lpaint = new Paint(Paint.ANTI_ALIAS_FLAG);
	
	double MIN_WIDTH = 200;
	double MIN_HEIGHT = 240;
	double MAX_WIDTH = 2000;
	double MAX_HEIGHT = 2400;
	
	MySurfaceView mSurfaceView;
	
	private static final int FORWARD = 0;
	private static final int RIGHT = 1;
	private static final int BACK = 2;
	private static final int LEFT = 3;
	
	private static final double[][] DELTA_X = 
		{	{ 0, 10, 0, -10 },
			{ 0, -10, 0, 10 } };

	private static final double[][] DELTA_Y = 
		{	{ 10, 0, -10, 0 },
			{ -10, 0, 10, 0 } };
	

	/** Paired firebird bot */
	Firebird fb5;
	boolean mConnected;
	
	/** Called when the activity is first created. */
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
		
		/*Creating buttons on the App*/
		//Button to connect the Android with the Firebird
		mConnectButton = (Button) findViewById(R.id.connect);
		mConnectButton.setOnClickListener(ConnectListener);

		//Button to disconnect the Android from the Firebird
		mDisconnectButton = (Button) findViewById(R.id.disconnect);
		mDisconnectButton.setOnClickListener(DisconnectListener);

		//
		mMapperButton = (Button) findViewById(R.id.map);
		mMapperButton.setOnClickListener(MapperListener);
		
		//
		mResetButton = (Button) findViewById(R.id.reset);
		mResetButton.setOnClickListener(ResetListener);
		
		//Button to stop the firebird
		mStopButton = (Button) findViewById(R.id.stop);
		mStopButton.setOnClickListener(StopListener);
		
		//Button which sends the map of the path generated by the bot through email
		mMailButton = (Button) findViewById(R.id.mail);
		mMailButton.setOnClickListener(MailListener);
		
		mConnectButton.setEnabled(true);
		mDisconnectButton.setEnabled(false);
		mMapperButton.setEnabled(false);
		mResetButton.setEnabled(true);
		mMailButton.setEnabled(true);
		
		fb5 = new Firebird();
		mConnected = false;

		cmdFwd = (Button)findViewById(R.id.cmdForward);
		cmdBck = (Button)findViewById(R.id.cmdBack);
		cmdLft = (Button)findViewById(R.id.cmdLeft);
		cmdRgt = (Button)findViewById(R.id.cmdRight);
		
		cmdFwd.setOnClickListener(new Button.OnClickListener(){
			public void onClick(View arg0) {
				cmdResponse(FORWARD);
			}
		});
		
		cmdBck.setOnClickListener(new Button.OnClickListener(){
			public void onClick(View arg0) {
				cmdResponse(BACK);
			}
		});
		
		cmdLft.setOnClickListener(new Button.OnClickListener(){
			public void onClick(View arg0) {
				cmdResponse(LEFT);
			}
		});
		
		cmdRgt.setOnClickListener(new Button.OnClickListener(){
			public void onClick(View arg0) {
				cmdResponse(RIGHT);
			}
		});
		
		path = new ArrayList<MyPoint>();
		screenPath = new ArrayList<MyPoint>();
		curr = new MyPoint();
		curr.x = 0;
		curr.y = 0;
		path.add(new MyPoint(curr));
		screenPath.add(new MyPoint(curr));
		orientation = FORWARD;
		angle = 90;
		
		mSurfaceView = (MySurfaceView) this.findViewById(R.id.mySurfaceView);
		if (mSurfaceView == null){
			Log.e(TAG, "Cannot get surface view!!");
		}
		else {
			initBitmap();
			redrawBitmap();
		}
	}
	
	/** Called when 'Connect' button is clicked. Starts the connection procedure over BT*/
	private OnClickListener ConnectListener = new OnClickListener()  
	{  
		public void onClick(View v)  
		{         
			Log.d(TAG,"Connect Requested");
			Toast.makeText(MapperBotActivity.this, "Connecting...", Toast.LENGTH_LONG).show();
			mConnected = fb5.startup();
			if (mConnected){
				Toast.makeText(MapperBotActivity.this, " Connection established ", Toast.LENGTH_SHORT).show();
				mConnectButton.setEnabled(false);
				mDisconnectButton.setEnabled(true);
				mMapperButton.setEnabled(true);
			}
				
			else
				Toast.makeText(MapperBotActivity.this, " No connection established ", Toast.LENGTH_SHORT).show();

			
		}  
	};
	
	/** Called when 'Disconnect' button is pressed. Frees the BT channel and stop accelerometer listener. */
	private OnClickListener DisconnectListener = new OnClickListener()  
	{  
		public void onClick(View v)  
		{         
			Log.d(TAG,"Disonnect Requested");
			fb5.disconnect();
			Toast.makeText(MapperBotActivity.this, " Disconnected ", Toast.LENGTH_SHORT).show();

			mConnectButton.setEnabled(true);
			mDisconnectButton.setEnabled(false);
			mMapperButton.setEnabled(false);
		}    
	};
	
	ArrayList<BotMove> trace = null;
	int state = BotMove.FORWARD;
	/*Called when 'MAP' button is clicked. This enables the wheel interrupt values and starts Adaptive Cruise Control. The bot is asked to move forward */
	private OnClickListener MapperListener = new OnClickListener() {
		public void onClick(View v) {	
			Toast.makeText(MapperBotActivity.this, "Following the Wall... " , Toast.LENGTH_SHORT).show();
			
			fb5.enableLeftWheelInterrupt();
			fb5.enableRightWheelInterrupt();
			fb5.accModifiedStart();

			trace = new ArrayList<BotMove>();

			fb5.moveForward();
			state = 0;

			Log.d (TAG, "starting wall follow thread ... ");
			wt = new WallFollowThread();
			wt.start();
		}
	};
	
	
	/*Called when the 'Reset' button is clicked. This stops the bot and clears the canvas*/
	private OnClickListener ResetListener = new OnClickListener() {
		public void onClick(View v) {
			path = new ArrayList<MyPoint>();
			screenPath = new ArrayList<MyPoint>();
			curr = new MyPoint();
			curr.x = 0;
			curr.y = 0;
			path.add(new MyPoint(curr));
			screenPath.add(new MyPoint(curr));
			orientation = FORWARD;
			angle = 90;
			
			redrawBitmap();
			
			if (wt != null){
				boolean wt_running = true;
				while (wt_running){
					try {
						wt.join();
						wt_running = true;
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				fb5.stop();
				fb5.accStop();
				fb5.getCommunicationModule().setClientHandler(null);
				fb5.getCommunicationModule().setBytesExpected(0);
				fb5.getCommunicationModule().setMsgExpected(-1);
			}
		}
	};
	
	/*This is called when the 'Stop' button is clicked. This stops the bot and also stops ACC.*/
	private OnClickListener StopListener = new OnClickListener() {
		public void onClick(View v) {
			if (wt != null){
				wt.stop();
				fb5.stop();
				fb5.accStop();
				fb5.getCommunicationModule().setClientHandler(null);
				fb5.getCommunicationModule().setBytesExpected(0);
				fb5.getCommunicationModule().setMsgExpected(-1);
			}
		}
	};
	
	/*This is called when the 'Mail' button is clicked. It sends the picture of the path made by the bot through email*/
	private OnClickListener MailListener = new OnClickListener() {
		public void onClick(View v) {
			if (mBitmap != null){
				FileOutputStream fos;
				try {
					SimpleDateFormat s = new SimpleDateFormat("yyyyMMddhhmmss");
					String format = s.format(new Date());
					fos = openFileOutput(format + ".jpg", Context.MODE_WORLD_READABLE);
					
					// Use the compress method on the BitMap object to write image to the OutputStream
					mBitmap.compress(Bitmap.CompressFormat.JPEG, 50, fos);
					
					Log.d(TAG, "Sending email...");
					Toast.makeText(MapperBotActivity.this, "Sending email...", Toast.LENGTH_SHORT);
					try {   
	                    GMailSender sender = new GMailSender("mapperbot.fb.api@gmail.com", "mapperbot.fb.api");
	                    sender.sendMail("MapperBot Spy Image " + format,   
	                            "Taken at " + format,   
	                            "mapperbot.fb.api@gmail.com",   
	                            "pararthshah717@gmail.com",
	                            format + ".jpg");  
	                    
	                    Log.d(TAG, "Email sent!");
	                    Toast.makeText(MapperBotActivity.this, "Mail sent!", Toast.LENGTH_SHORT);
	                } catch (Exception e) {   
	                    Log.e("SendMail", e.getMessage(), e);
	                    Toast.makeText(MapperBotActivity.this, "Mail not sent!", Toast.LENGTH_SHORT);
	                } 
					
					
				} catch (FileNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
					Log.d(TAG, "Could not send email");
					Toast.makeText(MapperBotActivity.this, "Error: Could not send email", Toast.LENGTH_SHORT);
				}

				
			}
		}
	};

	/* WallFollower functions */

	WallFollowThread wt = null;

	/*Thread which executes the code for the bot to follow the wall*/
	class WallFollowThread extends Thread {
		boolean take_reading = true;
		boolean turning = false;
		public void run () {
			while (true) {
				//Check if the bot has stopped due to an obstacle. Also obtain the sensor values
				if (take_reading) {
					fb5.getCommunicationModule().setBytesExpected(1);
					fb5.getCommunicationModule().setMsgExpected(ACC_CHECK);
					fb5.getCommunicationModule().setClientHandler(mHandler);
					
					fb5.accCheck();
					fb5.getSensor((char)LEFT_PROX_VALUE);
					fb5.getSensor((char)FORWARD_PROX_VALUE);
					fb5.getSensor((char)LEFT_SHARP_VALUE);
					fb5.getSensor((char)FORWARD_SHARP_VALUE);

					Log.d (TAG, "taking readings ...");

					//THIS ORDER MUST REMAIN THE SAME - leftsharp and then forwardsharp
					take_reading = false;
				}
				//The bot is turning and the Android waits for the bot to complete the turn
				else if (turning){
					fb5.getCommunicationModule().setBytesExpected(1);
					fb5.getCommunicationModule().setMsgExpected(TURN_SUCCESS);
					fb5.getCommunicationModule().setClientHandler(mHandler);

					Log.d (TAG, "waiting for turn success ...");
					turning = false;
				}
			}
		}
	}

	Handler mHandler = new Handler(){
		public void takeInterruptAction() {

			fb5.getCommunicationModule().setBytesExpected(4);
			fb5.getCommunicationModule().setMsgExpected(INTERRUPT_COUNT);
			fb5.getCommunicationModule().setClientHandler(mHandler);
			fb5.getLeftPosInterruptCount();
		}
		/*Sets the velocity of the Firebird on basis of the current state of the Firebird*/
		public void setVelocity () {
			fb5.getCommunicationModule().setClientHandler(null);
			if(state == BotMove.SHARP_RIGHT){
				fb5.setVelocity((byte)200,(byte)0);
			}
			else if(state == BotMove.LEFT){
				fb5.setVelocity((byte)100,(byte)200);
			}
			else if(state == BotMove.SOFT_RIGHT){
				fb5.setVelocity((byte)200,(byte)100);
			}
			else if(state == BotMove.FORWARD){
				wt.turning = false;
				Log.d(TAG,"Setting forward velocity");
				fb5.setVelocity((byte)150,(byte)150);
				
			}
			else if(state == BotMove.STOP){
				wt.turning = false;
				fb5.setVelocity((byte)0,(byte)0);
				return;
			}
			fb5.moveForward();
			fb5.accModifiedStart();
		}
		
		/*Asks the Firebird to turn by a certain angle on basis of the current state of the Firebird*/
		public void setRotation(){
			fb5.accStop();
			wt.turning = true;
			if(state == BotMove.RIGHT_15){
				fb5.turnRightBy(6);
				angle = (angle+360-20)%360;
			}
			else if(state == BotMove.RIGHT_10){
				fb5.turnRightBy(3);
				angle = (angle+360-10)%360;
			}
			else if(state == BotMove.LEFT_5){
				fb5.turnLeftBy(2);
				angle = (angle+360+5)%360;
			}
		}

		/*Sets the state of the Firebird i.e if the Firebird is moving forward, the state is set accordingly, etc.*/
		public void setState (int new_state, int force) {
			Log.d ("STATE", "New state : " + new_state);
			if (new_state >= BotMove.RIGHT_15 && new_state <= BotMove.LEFT_5){
				state = new_state;
				takeInterruptAction();
			}
			else if(state != new_state || force == 1){
				state = new_state;
				takeInterruptAction();
			}
			else wt.take_reading = true;
		}
		
		public void setState (int new_state){
			setState(new_state, 0);
		}
		
		@Override
		public void handleMessage(Message msg) {
			Log.d(TAG, "Handler recieved message : " + msg.what );
			//The Firebird has turned successfull and Android can now send further commands
			if (msg.what == TURN_SUCCESS){
				wt.turning = false;
				wt.take_reading = true;
			}
			//Recieve the value of the Interrupt Count
			else if (msg.what == INTERRUPT_COUNT){
				Log.d(TAG, "Handler processing message");
				byte[] value = (byte[])msg.obj;
				if (value.length == 4){
					int count = (int)(value[0] << 24);
					count += (int)(value[1] << 16);
					count += (int)(value[2] << 8);
					count += (int)value[3];
					Log.d(TAG, "Interrupt count : " + count);
					
					if (count > (1 << 16)){
						//error in interrupt count;
						Log.d(TAG, "Error in interrupt count, checking again!");
						takeInterruptAction();
						return;
					}

					BotMove bm = new BotMove (count,state);
					trace.add(bm);
					
					if (state >= BotMove.RIGHT_15) {
						distanceTravelled = (double)count;
						calcNewPosition();
						setRotation();
					}
					else {
						distanceTravelled = (double)count;
						calcNewPosition();
						setVelocity();
						wt.take_reading = true;
					}
				}
			}
			//If the firebird has stopped due to an obstacle, obtain the left proximity sensor value
			else if (msg.what == ACC_CHECK){
				Log.d(TAG, "Handler processing message");
				byte[] value = (byte[])msg.obj;
				if (value.length == 1){
					acccheck = (int)value[0];
					fb5.getCommunicationModule().setBytesExpected(1);
					fb5.getCommunicationModule().setMsgExpected(LEFT_PROX_VALUE);
					fb5.getCommunicationModule().setClientHandler(mHandler);
				}
			}
			//Reading the front sharp value of the  Firebird and acting accordingly
			else if (msg.what == FORWARD_SHARP_VALUE){
				Log.d(TAG, "Handler processing message");
				byte[] value = (byte[])msg.obj;
				if (value.length == 1){
					forwardsharp = (int)value[0];
					forwardsharp = forwardsharp < 0 ? 256 + forwardsharp : forwardsharp;

					boolean fwd_wall = (fwdprox < FORWARD_PROX_THRESHOLD) || (forwardsharp > FWD_SHARP_MAX_THRESHOLD);
					boolean fwd_wall_too_close = (fwdprox < FORWARD_PROX_THRESHOLD) || (forwardsharp > FWD_SHARP_MIN_THRESHOLD);
					boolean left_wall = (leftprox < LEFT_PROX_MAX_THRESHOLD) || (leftsharp > LEFT_SHARP_MIN_THRESHOLD);
					boolean left_wall_too_close = (leftprox < LEFT_PROX_MIN_THRESHOLD) || (leftsharp > LEFT_SHARP_MAX_THRESHOLD * 2.0);

					Log.d("SENSOR", "botState : " + botState + " FWD : " + forwardsharp + " FWDP : " + fwdprox + " LT : " + leftsharp + " LTP : " + leftprox + " " + fwd_wall + " " + left_wall + " " + left_wall_too_close);
					
					if (acccheck == 1){
						botState = 1;
						setState(BotMove.FORWARD);
					}
					else {
						if (botState == 0) { // WALL FINDING
							//stop the bot if it is close to the left wall and front wall. set botstate = 1 indicating wall has been found
							if (left_wall && fwd_wall) {
								botState = 1;
								setState(BotMove.STOP);
							}
							//continue motion of the bot if it is close to the left wall. set botstate = 1 indicating wall has been found
							else if (left_wall && !fwd_wall){
								botState = 1;
								setState (state);
							}
							//stop the bot if it is close to the front wall. set botstate = 1 indicating wall has been found
							else if (!left_wall && fwd_wall){
								botState = 1;
								setState (BotMove.STOP);
							}
							//continue moving forward until bot reaches wall
							else {
								if (acccheck == 2) setState (BotMove.FORWARD, 1); 
								else setState (BotMove.FORWARD);
							}
						}
						else if (botState == 1) { //WALL FOLLOWING MODE
							//If the front wall is too close turn the bot right
							if (fwd_wall_too_close) {
								setState (BotMove.RIGHT_15);
							}
							//If the left wall is too close turn the bot right
							else if (left_wall_too_close) {
								setState (BotMove.RIGHT_10);
							}
							//If the left wall is close but not too close make the bot move forward
							else if (left_wall && !fwd_wall){
								if (acccheck == 2) setState (BotMove.FORWARD, 1); 
								else setState (BotMove.FORWARD);
							}
							//If the left and front walls are close but not too close make the bot move forward
							else if (left_wall && fwd_wall){
								if (acccheck == 2) setState (BotMove.FORWARD, 1); 
								else setState (BotMove.FORWARD);
							}
							// If the left wall is not close then turn left if bots state was not already turning right
							else if (fwd_wall){
								if (state == BotMove.RIGHT_10 || state == BotMove.RIGHT_15){
									setState (BotMove.RIGHT_10);
								}
								else setState(state);
							}
							else {
								wall_expected++;
								setState(BotMove.LEFT_5);
								if (wall_expected >= 7){
									wall_expected = 0;
									botState = 0;
								}
							}
						}
						else {
							Log.d (TAG, "Unrecognized state");
						}
					}
					
					
				}
			}
			//Read the left sharp sensor value and expect the forward sharp sensor value next
			else if (msg.what == LEFT_SHARP_VALUE){
				Log.d(TAG, "Handler processing message");
				byte[] value = (byte[])msg.obj;
				if (value.length == 1){
					leftsharp = (int)value[0];
					leftsharp = leftsharp < 0 ? 256 + leftsharp : leftsharp;
					Log.d(TAG, "Left sharp : " + leftsharp);

					fb5.getCommunicationModule().setBytesExpected(1);
					fb5.getCommunicationModule().setMsgExpected(FORWARD_SHARP_VALUE);
					fb5.getCommunicationModule().setClientHandler(mHandler);
					//fb5.getSensor((char)FORWARD_SHARP_VALUE);				
				}
			}
			//Read the left sharp proximity value and expect the forward proximity sensor value next
			else if (msg.what == LEFT_PROX_VALUE){
				Log.d(TAG, "Handler processing message");
				byte[] value = (byte[])msg.obj;
				if (value.length == 1){
					leftprox = (int)value[0];
					leftprox = leftprox < 0 ? 256 + leftprox : leftprox;
					Log.d(TAG, "Left prox : " + leftprox);

					fb5.getCommunicationModule().setBytesExpected(1);
					fb5.getCommunicationModule().setMsgExpected(FORWARD_PROX_VALUE);
					fb5.getCommunicationModule().setClientHandler(mHandler);
					//fb5.getSensor((char)FORWARD_PROX_VALUE);				
				}
			}
			//Read the forward proximity value and expect the left sharp sensor value next
			else if (msg.what == FORWARD_PROX_VALUE){
				Log.d(TAG, "Handler processing message");
				byte[] value = (byte[])msg.obj;
				if (value.length == 1){
					fwdprox = (int)value[0];
					fwdprox = fwdprox < 0 ? 256 + fwdprox : fwdprox;
					Log.d(TAG, "Fwd prox : " + fwdprox);

					fb5.getCommunicationModule().setBytesExpected(1);
					fb5.getCommunicationModule().setMsgExpected(LEFT_SHARP_VALUE);
					fb5.getCommunicationModule().setClientHandler(mHandler);
					//fb5.getSensor((char)LEFT_SHARP_VALUE);				
				}
			}
			else Toast.makeText(MapperBotActivity.this, "Firebird Read Error " + msg.what, Toast.LENGTH_SHORT).show();
		}
	};
	
	public boolean cmdResponse(int cmdType){
		Log.d(TAG,"cmd: " + cmdType + " orientation: " + orientation);
		if (cmdType == FORWARD){
			curr.x += DELTA_X[0][orientation];
			curr.y += DELTA_Y[0][orientation];
			path.add(new MyPoint(curr));
			screenPath.add(new MyPoint(curr));
		}
		else if (cmdType == BACK){
			curr.x += DELTA_X[1][orientation];
			curr.y += DELTA_Y[1][orientation];
			path.add(new MyPoint(curr));
			screenPath.add(new MyPoint(curr));
		}
		else if (cmdType == LEFT){
			orientation = (orientation-1+4)%4;
		}
		else if (cmdType == RIGHT){
			orientation = (orientation+1+4)%4;
		}
		else return false;
		
		redrawBitmap();
		return true;
	}
	
	
	/** Display functions */
	
	public void calcNewPosition(){
		curr.x += distanceTravelled*Math.cos(Math.PI*angle/180);
		curr.y += distanceTravelled*Math.sin(Math.PI*angle/180);
		path.add(new MyPoint(curr));
		screenPath.add(new MyPoint(curr));
		
		redrawBitmap();
	}
	
	
	public void initBitmap(){
		cpaint.setStyle(Paint.Style.STROKE);
		cpaint.setStrokeWidth(3);
		cpaint.setColor(Color.WHITE);
		
		lpaint.setStrokeWidth(2);  //2 pixel line width
		lpaint.setColor(Color.WHITE);
		lpaint.setStyle(Paint.Style.STROKE); //stroked, aka a line with no fill
		lpaint.setAntiAlias(true);  // no jagged edges, etc.

	}
	
	public boolean redrawBitmap(){
		double lowx=Float.MAX_VALUE, lowy=Float.MAX_VALUE, highx=Float.MIN_VALUE, highy=Float.MIN_VALUE;
		
		for (MyPoint p : path){
			if (lowx > p.x) lowx = p.x;
			if (lowy > p.y) lowy = p.y;
			if (highx < p.x) highx = p.x;
			if (highy < p.y) highy = p.y;
		}
		
		double pt_width = highx - lowx;
		double pt_height = highy - lowy;
		
		double bm_width = 1.1*pt_width;
		double bm_height = 1.1*pt_height;
		
		if (bm_width < MIN_WIDTH) {
			bm_width = MIN_WIDTH;
		}
		if (bm_height < MIN_HEIGHT) {
			bm_height = MIN_HEIGHT;
		}
		
		double scale_x = bm_width / MAX_WIDTH;
		double scale_y = bm_height / MAX_HEIGHT;
		
		if (scale_x > 1 || scale_y > 1){
			scale_x = Math.max(scale_x, scale_y);
		}
		else scale_x = 1;
		
		bm_width /= scale_x;
		bm_height /= scale_x;
		
		Log.d(TAG, "w: " + bm_width + " h: " + bm_height + " sc : " + scale_x);
		
		double pt_center_x = lowx + (pt_width / 2.0);
		double pt_center_y = lowy + (pt_height / 2.0);
		double bm_center_x = bm_width / 2.0;
		double bm_center_y = bm_height / 2.0;
		
		mBitmap = Bitmap.createBitmap((int)bm_width, (int)bm_height, Bitmap.Config.ARGB_8888);
		mCanvas = new Canvas(mBitmap);
		
		mCanvas.drawRGB(0, 0, 0);
		
		for (int i = 0; i < path.size(); i++){
			screenPath.get(i).x = ((path.get(i).x - (float)pt_center_x)/(float)scale_x) + (float)bm_center_x;
			screenPath.get(i).y = (-1*(path.get(i).y - (float)pt_center_y)/(float)scale_x) + (float)bm_center_y;
			
			Log.d(TAG,"point: " + screenPath.get(i).x + " " + screenPath.get(i).y);
		}
		
		int i = 0;
		for (; i < screenPath.size()-1; i++){
			mCanvas.drawLine(screenPath.get(i).x, screenPath.get(i).y, screenPath.get(i+1).x, screenPath.get(i+1).y, lpaint);
		}
		
		mCanvas.drawCircle(screenPath.get(i).x, screenPath.get(i).y, 3, cpaint);
		
		Log.d(TAG, "setting bitmap");
        mSurfaceView.setBitmap(mBitmap);
		return true;
	}
}